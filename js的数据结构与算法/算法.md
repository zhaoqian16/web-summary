# 算法（algorithm）

## 数组



## 栈结构

### 什么是栈结构

栈，是一种受运算限制的线性表

- 后进先出（LIFO--last in first out）
- 限制：仅允许在表的一端进行插入和删除运算。这一端是栈顶，另一端是栈底。
- 进栈：把新元素放到栈顶元素的上面，使之成为新的栈顶元素。
- 出栈：把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。

![img](imgs/1102036-9253975a5d43fdb0)

### 栈结构的封装

```javascript
function Stack() {
    this.items = []
    
    Stack.prototype.push = function(item) {
      return this.items.push(item)
    }

    Stack.prototype.pop = function() {
      return this.items.pop()
    }

    Stack.prototype.top = function() {
      return this.items[this.items.length-1]
    }

    Stack.prototype.size = function() {
      return this.items.length
    }

    Stack.prototype.isEmpty = function() {
      return !this.items.length
    }

    Stack.prototype.toString = function() {
      var formatStr=''
      for(var i=0; i<this.items.length; i++) {
        formatStr = formatStr + this.items[i]
      }
      return formatStr
    }
  }
```



### 栈-十进制转二进制

```javascript
function decimal2Binary(value) {
    var stack = new Stack()
    while (value >= 1) {
      value = Math.floor(value / 2)
      remainder = value % 2
      stack.push(remainder)
    }
    return stack.toString()
  }
```

### 栈-中缀表达式转为后缀表达式





## 队列

### 什么是队列结构

队列结构，也是一种线性表。

- 允许在队尾插入元素，在队首删除元素，FIFO（first in first out）

![这里写图片描述](imgs/2018071817393646)

### 队列结构的封装

常见操作：

- enqueue(element)
- dequeue
- front
- isEmpty 
- size
- toString

```javascript
function Queue() {
    this.items = []

    Queue.prototype.enqueue = function(item) {
        return this.items.push(item)
    }

    Queue.prototype.dequeue = function() {
        return this.items.shift()
    }

    Queue.prototype.front = function() {
        return this.items[0]
    }

    Queue.prototype.isEmpty = function() {
        return !this.items.length
    }

    Queue.prototype.size = function() {
        return this.items.length
    }

    Queue.prototype.toString = function() {
        var formatStr = ''
        for(var i=0; i<this.items.length; i++) {
            formatStr = formatStr + this.items[i] + " "
        }
        return formatStr
    }
}
```



### 队列-击鼓传花

```javascript
function game(nameList, num) {
    var queue = new Queue()
    for (let i=0; i<nameList.length; i++) {
        queue.enqueue(nameList[i])
    }
    
    while (queue.size() > 1) {
        for (let i=0; i<num-1; i++) {
            queue.enqueue(queue.dequeue())
        }
        queue.dequeue()
    }
    return queue.front()
}
game(['熊大', '熊二', '熊三', '熊四', '熊五'], 4)
```



## 优先级队列

### 什么是优先级队列？



### 优先级队列的封装及实现

```javascript
function PriorityQueue() {
    
    function QueueElement(element, priority) {
        this.element = element
        this.priority = priority
	}
    
    this.items = []
    PriorityQueue.prototype.enqueue = function(element, priority) {
        var queueElement = new QueueElement(element, priority)
        
        if (this.items.length === 0) {
            this.items.push(queueElement)
        } else {
            var added = false
            for (var i=0; i<this.items.length; i++) {
                if (queueElemnt.priority < this.items[i].priority) {
                    this.items.splice(i, 0, queueElement)
                    added = true
                    break
                }
            }
            if (!added) {
                this.items.push(queueElement)
            }
        }
    }
}
```



## 链表结构

### 什么是链表结构

- 链表的优点
- 链表的缺点



### 链表结构的常见操作

- append(element)
- insert(position, element)
- get(position)
- indexOf(element)
- update(data, position)
- removeAt(position)
- remove(element)
- isEmpty()
- size()
- toString()

### 链表的封装

```javascript
function LinkedList() {
    function Node(data) {
      this.data = data
      this.next = null
    }

    this.head = null
    this.length = 0
  }

```

#### append

```javascript
LinkedList.prototype.append = function(data) {
    var node = new Node(data)
    if (this.head === null) {
        this.head = node
    } else {
        var current = this.head
        while (current.next) {
            current = current.next
        }
        current.next = node
    }
    this.length++
}
```

#### insert

```javascript
LinkedList.prototype.insert = function(data, position) {
    if (position < 0 || position > this.length) return false
    var node = new Node(data)
    var current = this.head
    if (position === 0) {
        node.next = current
        this.head = node
    } else {
        var index = 0
        var previous
        while(index++ < position) {
            previous = current
            current = current.next
        }
        node.next = current
        previous.next = node
    }
    this.length++
    return true
}
```

#### removeAt

```javascript
LinkedList.prototype.removeAt = function(position) {
    if (position < 0 || position >= this.length) return false
    var current = this.head
    if (position === 0) {
        this.head = current.next
    } else {
        var index = 0
        var previous
        while(index++ < position) {
            previous = current
            current = current.next
        }
        previous.next = current.next
    }
    this.length--
    return true
}
```

#### indexOf

```javascript
LinkedList.prototype.indexOf = function(element) {
    var index = 0
    var current = this.head
    while(index < this.length) {
        var data = current.data
        if(data === element) {
            return index
        }
        current = current.next
        index++
    }
    return -1
}
```

####  get

```javascript
LinkedList.prototype.get = function(position) {
    if (position < 0 || position >= this.length) return null
    var index = 0
    var current = this.head
    while(index++ < position) {
        current = current.next
    }
    return current.data
}
```

#### remove

```javascript
LinkedList.prototype.remove = function(element) {
    var index = this.indexOf(element)
    if (index === -1) return false
    return this.removeAt(index)
}
```

#### update

```javascript
LinkedList.prototype.update = function(data, position) {
    if (position < 0 || position >= this.length) return false
    var index = 0
    var current = this.head
    while(index++ < position) {
        current = current.next
    }
    current.data = data
    return true
}
```

#### isEmpty

```javascript
LinkedList.prototype.isEmpty = function() {
    if (this.length === 0) return true
    return false
}
```

#### size

```javascript
LinkedList.prototype.size = function() {
    return this.length
}
```

#### toString

```javascript
LinkedList.prototype.toString = function() {
    var formatStr = ""
    var index = 0
    var current = this.head
    while(index++ < this.length) {
        formatStr += current.data + " "
        current = current.next
    } 
    return formatStr
}
```

## 双向链表

### 什么是双向链表结构？

既可以从头遍历到尾，又可以从尾遍历到头。

图解：

![image-20210121141222618](imgs/image-20210121141222618.png)

### 封装双向链表

```javascript
function DoublyList() {
    function Node(data) {
        this.data = data
        this.prev = null
        this.next = null
    }
    this.head = null
    this.tail = null
    this.length = 0
}
```



### 双向链表常见操作

- `append(element)`

- `insert(position, element)`
- `get(position)`
- `indexOf(element)`
- `update(position, element)`
- `removeAt(position)`
- `remove(element)`
- `isEmpty()`
- `size()`
- `toString()`
- `forwardString()`
- `backwordString()`



### 双向链表的方法实现

#### `append`

```
DoublyList.prototype.append = function(data) {
    // 情况1：this.length = 0
    // 情况2：this.length != 0
    var node = new Node(data)
    if (this.length === 0) {
    this.head = node
    this.tail = node
    } else {
    this.tail.next = node
    node.prev = this.tail
    this.tail = node
    }
    this.length += 1
}
```

#### `forwardString`

```javascript
DoublyList.prototype.forwardString = function() {
    var formatStr = ""
    var current = this.tail
    while(current) {
        formatStr += current.data + " "
        current = current.prev
    }
    return formatStr
}
```

#### `backwordString`

```javascript
DoublyList.prototype.backwordString = function() {
    var formatStr = ""
    var current = this.head
    while(current) {
        formatStr += current.data + " "
        current = current.next
    }
    return formatStr
}
```

#### `toString`

```javascript
DoublyList.prototype.toString = function() {
    return this.backwordString()
}
```

#### `insert`

```javascript
DoublyList.prototype.insert = function(data, position) {
    if (position < 0 || position > this.length) return false
    var node = new Node(data)
    if (this.length === 0) {
        this.head = node
        this.tail = node
    } else {
        if (position === 0) {
            node.next = this.head
            this.head.prev = node
            this.head = node
        } else if (position === this.length) {
            node.prev = this.tail
            this.tail.next = node
            this.tail = node
        } else {
            var index = 0
            var current = this.head
            while(index++ < position) {
                current = current.next
            }
            current.prev.next = node
            node.prev = current.prev
            current.prev = node
            node.next = current
        }
    }
    this.length += 1
    return true
}
```

#### `get`

```javascript
DoublyList.prototype.get = function(position) {
    if (position < 0 || position > this.length-1)  return null
    if (position <= this.length / 2) { // 从前向后找
        var index = 0
        var current = this.head
        while(index++ < position) {
            current = current.next
        }
        return current.data
    } else if (position > this.length / 2) { // 从后向前找
        var index = this.length-1
        var current = this.tail
        while(index-- > position) {
            current = current.prev
        }
        return current.data
    }
}
```

#### `indexOf`

```javascript
DoublyList.prototype.indexOf = function(data) {
    var index = 0
    var current = this.head
    while(current) {
        if (data === current.data) return index
        current = current.next
        index++
    }
    return -1
}
```

#### `removeAt`

```javascript
DoublyList.prototype.removeAt = function(position) {
    if (position < 0 || position > this.length-1) return false
    if (position === 0) {
        this.head = this.head.next
        this.head.prev = null
    } else if (position === this.length-1) {
        this.tail = this.tail.prev
        this.tail.next = null
    } else {
        if (position <= this.length / 2) {
            var index = 0
            var current = this.head
            while(index++ < position) {
                current = current.next
            }
            current.prev.next = current.next
            current.next.prev = current.prev
        } else if (position > this.length / 2) {
            var index = this.length-1
            var current = this.tail
            while(index-- > position) {
                current = current.prev
            }
            current.prev.next = current.next
            current.next.prev = current.prev
        }
    }
    this.length -= 1
    return true
}
```

#### `remove`

```javascript
DoublyList.prototype.remove = function(data) {
    var index = this.indexOf(data)
    if (index === -1) return false
    return this.removeAt(index)
}
```

#### 其他方法

```javascript
DoublyList.prototype.isEmpty = function() {
    return this.length === 0
}

DoublyList.prototype.size = function() {
    return this.length
}

DoublyList.prototype.getHead = function() {
    return this.head.data
}

DoublyList.prototype.getTail = function() {
    return this.tail.data
}
```



## 集合结构

### 什么是集合结构？

由无序的、不能重复的元素构成。

- 没有顺序意味着：不能通过下标值访问
- 不能重复意味着：相同的对象在集合中只能存在一份

### 封装集合类

```javascript
function Set() {
  	this.items = {}
    Set.prototype.has = function(value) {
        return this.items.hasOwnProperty(value)
    }
}
```

### 集合常见操作

- add(value)
- remove(value)
- has(value)
- clear()
- size() 
- values()

### 集合常见操作--方法实现

```javascript
Set.prototype.add = function(value) {
    if (!this.has(value)) {
      this.items[value] = value
      return true
    }
    return false
  }
  Set.prototype.remove = function(value) {
    if (!this.has(value)) return false
    delete this.items[value]
    return true
  }
  Set.prototype.clear = function() {
    this.items = {}
  }
  Set.prototype.size = function() {
    return Object.keys(this.items).length
  }
  Set.prototype.values = function() {
    return Object.keys(this.items)
  }
```

### 集合间操作

- 并集
- 交集
- 差集
- 子集

### 集合间操作--方法实现

#### 并集`union`

```javascript
Set.prototype.union = function(otherSet) {
    var set = new Set()
    var values = this.values()
    for(var i=0; i < values.length; i++) {
        set.add(values[i])
    }

    var otherValues = otherSet.values()
    for(var i=0; i < otherValues.length; i++) {
        set.add(otherValues[i])
    }
    return set
}
```

#### 交集`intersection`

```javascript
Set.prototype.intersection = function(otherSet) {
    var set = new Set()
    var values = otherSet.values()
    for(var i=0; i < values.length; i++) {
        var value = values[i]
        if (this.has(value)) {
            set.add(value)
        }
    }
    return set
}
```

#### 差集`difference`

```javascript
Set.prototype.difference = function(otherSet) {
    var set = new Set()
    var values = otherSet.values()
    for(var i=0; i < values.length; i++) {
        var value = values[i]
        if (!this.has(value)) {
            set.add(value)
        }
    }
    return set
}
```

#### 子集`subset`

```javascript
Set.prototype.subset = function(otherSet) {
    var otherValues = otherSet.values()
    for(var i=0; i < otherValues.length; i++) {
        if(!this.has(otherValues[i])) {
            return false
        }
    }
    return true
}
```



## 字典类型

### 认识字典

数组-集合-字典是几乎编程语言都会默认提供的数据类型。

字典的特点：

- 一一对应

- 通过键值对的方式保存数据

- key是不可重复的，value可以重复，字典中的key是无序的 

字典和映射的关系：

- 有些编程语言称这种映射关系为字典
- 有些编程语言称这种映射关系为Map

字典和对象：

- 很多编程语言中对对象和字典的区分比较明显。
  - 对象通常是一种在编译期就确定下来的结构，不可以动态的添加或删除属性
  - 而字典通常会使用类似于哈希表的数据结构去实现一种可以动态的添加数据的结构
- 在Javascript中，似乎对象本身就是一种字典。



## 哈希表

哈希表是一种非常重要的数据结构。

数组的操作效率：

- 数组在进行插入时，效率非常低
- 数组进行查找操作的效率
  - 如果是基于索引进行查找，操作效率非常高
  - 基于内容查找，效率不高
- 数组进行删除操作，效率也不高

哈希表是基于数组实现的。

哈希表的优势：



哈希表的缺点：



哈希表到底是什么？



### 哈希表的一些概念

哈希化

哈希函数

哈希表



冲突



### 解决冲突？

- 链地址法

![image-20210122111324272](imgs/image-20210122111324272.png)

解析？



- 开放地址法

工作方式：寻找空白的单元格来添加重复的数据

![image-20210122112052784](imgs/image-20210122112052784.png)

 

### 哈希函数的封装

```javascript
function hashFunc(str, size) {
    var hashCode = 0
    for(var i=0; i<str.length; i++) {
        hashCode += str[i].charCodeAt()
    }
    hashCode = hashCode % size
    return hashCode
}
```

### 哈希表类的封装

```javascript
function HashTable() {
    this.storage = []
    this.count = 0
    this.limit = 7
}
```

#### 插入/修改方法

```javascript
HashTable.prototype.put = function(key, value) {
    // 1. 判断key值的哈希值
    var index = this.hashFunc(key, this.limit)
    // 2. 根据哈希值放入对应位置的bucket
    // 2.1 如果对应位置没有bucket，先创建，再放入
    var bucket = this.storage[index]
    if (bucket === undefined) {
        bucket = []
        this.storage[index] = bucket
    }

    // 2.2 对应位置有bucket
    // 2.2.1 bucket中有key值，修改
    // 2.2.2 bucket中没有key值，添加
    var override = false
    for (var i=0; i < bucket.length; i++) {
        var turple = bucket[i]
        if (turple[0] === key) { // 更新
            turple[1] = value
            override = true
        }
    }
    if (!override) {
        bucket.push([key, value]) // 插入
        this.count += 1
    }
}
```

#### 获取方法

```javascript
HashTable.prototype.get = function(key) {
    var index = this.hashFunc(key, this.limit)
    var bucket = this.storage[index]
    if (bucket === null) return null

    for (var i=0; i < bucket.length; i++) {
        var turple = bucket[i]
        if (turple[0] === key) {
            return turple[1]
        }
    }

    return null
}
```



#### 删除方法

```javascript
HashTable.prototype.remove = function(key) {
    var index = this.hashFunc(key, this.limit)
    var bucket = this.storage[index]
    if (bucket === null) return false

    for(var i=0; i < bucket.length; i++) {
        var turple = bucket[i]
        if (turple[0] === key) {
            bucket.splice(i, 1)
            this.count -= 1
            return true
        }
    }

    return false
}
```



#### 其他方法

- `isEmpty()`
- `size()`

```javascript
HashTable.prototype.isEmpty = function() {
    return this.count === 0
}

HashTable.prototype.size = function() {
    return this.count
}
```



### 哈希表的扩容

为什么需要扩容？



如何进行扩容？



什么情况下扩容？



扩容/缩容封装

 ```javascript
HashTable.prototype.resize = function(size) {
    this.limit = size
    var oldStorage = this.storage
    this.storage = []
    this.count = 0

    for(var i=0; i < oldStorage.length; i++) {
        var oldBucket = oldStorage[i]
        if (oldBucket !== undefined) {
            for (var j=0; j < oldBucket.length; j++) {
                var turple = oldBucket[j]
                this.put(turple[0], turple[1])
            }
        }
    }
}
 ```

添加数据时扩容：

```javascript
if (this.count > 0.75 * this.limit) {
    var primeNum = this.getPrime(this.limit * 2)
    this.resize(primeNum)
}
```

删除数据时缩容：

```javascript
if (this.count < 0.25 * this.limit) {
    var primeNum = this.getPrime(Math.floor(this.limit / 2))
    this.resize(primeNum)
}
```

### 实现容量恒为质数

#### 质数判断--普通算法

```javascript
function isPrime(value) {
    for (var i=2; i < value; i++) {
        if (value % i === 0) {
            return false
        }
    }
    return true
}
```

#### 质数判断--更高效的算法

```javascript
function isPrime(value) {
    var temp = parseInt(Math.sqrt(value))
    for (var i=2; i <= temp; i++) {
        if (value % i === 0) {
            return false
        }
    }
    return true
}
```

#### 哈希表中容量恒为质数

```javascript
HashTable.prototype.getPrime = function(value) {
    while(value++) {
        if (this.isPrime(value)) return value
    }
}
HashTable.prototype.isPrime = function(value) {
    var temp = parseInt(Math.sqrt(value))
    for (var i=2; i <= temp; i++) {
        if (value % i === 0) {
            return false
        }
    }
    return true
}
```

###  完整代码

```javascript
function HashTable() {
    this.storage = []
    this.count = 0
    this.limit = 7

    HashTable.prototype.hashFunc = function(str, size) {
        var hashCode = 0
        for(var i=0; i<str.length; i++) {
            hashCode += str[i].charCodeAt()
        }
        hashCode = hashCode % size
        return hashCode
    }

    HashTable.prototype.put = function(key, value) {
        // 1. 判断key值的哈希值
        var index = this.hashFunc(key, this.limit)
        // 2. 根据哈希值放入对应位置的bucket
        // 2.1 如果对应位置没有bucket，先创建，再放入
        var bucket = this.storage[index]
        if (bucket === undefined) {
            bucket = []
            this.storage[index] = bucket
        }

        // 2.2 对应位置有bucket
        // 2.2.1 bucket中有key值，修改
        // 2.2.2 bucket中没有key值，添加
        var override = false
        for (var i=0; i < bucket.length; i++) {
            var turple = bucket[i]
            if (turple[0] === key) { // 更新
                turple[1] = value
                override = true
            }
        }
        if (!override) {
            bucket.push([key, value]) // 插入
            this.count += 1
            this.loadFacotr = this.count / this.limit
            if (this.count > 0.75 * this.limit) {
                var primeNum = this.getPrime(this.limit * 2)
                this.resize(primeNum)
            }
        }
    }

    HashTable.prototype.get = function(key) {
        var index = this.hashFunc(key, this.limit)
        var bucket = this.storage[index]
        if (bucket === null) return null

        for (var i=0; i < bucket.length; i++) {
            var turple = bucket[i]
            if (turple[0] === key) {
                return turple[1]
            }
        }

        return null
    }

    HashTable.prototype.remove = function(key) {
        var index = this.hashFunc(key, this.limit)
        var bucket = this.storage[index]
        if (bucket === null) return false

        for(var i=0; i < bucket.length; i++) {
            var turple = bucket[i]
            if (turple[0] === key) {
                bucket.splice(i, 1)
                this.count -= 1
                if (this.count < 0.25 * this.limit) {
                    var primeNum = this.getPrime(Math.floor(this.limit / 2))
                    this.resize(primeNum)
                }
                return true
            }
        }

        return false
    }

    HashTable.prototype.isEmpty = function() {
        return this.count === 0
    }

    HashTable.prototype.size = function() {
        return this.count
    }

    HashTable.prototype.resize = function(size) {
        this.limit = size
        var oldStorage = this.storage
        this.storage = []
        this.count = 0

        for(var i=0; i < oldStorage.length; i++) {
            var oldBucket = oldStorage[i]
            if (oldBucket !== undefined) {
                for (var j=0; j < oldBucket.length; j++) {
                    var turple = oldBucket[j]
                    this.put(turple[0], turple[1])
                }
            }
        }
    }

    HashTable.prototype.isPrime = function(value) {
        var temp = parseInt(Math.sqrt(value))
        for (var i=2; i <= temp; i++) {
            if (value % i === 0) {
                return false
            }
        }
        return true
    }

    HashTable.prototype.getPrime = function(value) {
        while(value++) {
            if (this.isPrime(value)) return value
        }
    }
}
```



### 代码测试

```javascript
var hashTable = new HashTable()
  hashTable.put('aaa', 'aaa')
  hashTable.put('bbb', 'bbb')
  hashTable.put('ccc', 'ccc')

  console.log(hashTable.get('ccc'))
  hashTable.put('ccc', 'mmm')
  console.log(hashTable.get('ccc'))

  console.log(hashTable.size())
  hashTable.remove('bbb')
  console.log(hashTable.get('bbb'))

  hashTable.put('ddd', 'ddd')
  hashTable.put('eee', 'eee')
  hashTable.put('fff', 'fff')
  hashTable.put('abc', 'abc')
  hashTable.put('cde', 'cde')
  hashTable.put('cba', 'cba')
  hashTable.put('dea', 'dea')
  hashTable.put('dfr', 'dfr')
  hashTable.put('yyy', 'yyy')
  hashTable.put('eee', 'eee')
  hashTable.put('ttt', 'cde')
  hashTable.put('nnn', 'cba')
  console.log(hashTable.size())
```



## 树结构

### 认识树结构

树的优点：

|        | 优点                                                         | 缺点                                                         |
| ------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数组   | 根据下标值访问效率高。<br />根据元素来查找对应的位置时，较好的方式使先对数组进行排序，再进行二分查找。 | 需要先对数组进行排序，生成有序数组，才能提高查找效率。（效率`O(logN)`）<br />数组在插入和删除数据时，需要有大量的位移操作，效率很低。 |
| 链表   | 插入和删除操作效率都很高                                     | 查找效率低。需要从头开始一次访问链表中的每个数据项，直到找到。<br />即使插入和删除操作的效率很高，但是如果要插入和删除中间位置的数据，还是要重头先找到对应的数据。 |
| 哈希表 | 插入/查询/删除效率高。                                       | 空间利用率不高，底层使用的数组，冰鞋某些单元是没有被利用的。<br />哈希表中的元素是无序的，不能按照固定的顺序来遍历哈希表中的元素。<br />不能快速的找出哈希表中的最大值或最小值这些特殊的值。 |
| 树结构 | 不能说树结构比其他结构都要好，因为每种数据结构都有自己特定的应用场景。<br />    但是树结构也综合了上面的数据结构的优点（当然优点不足以盖过其他数据结构，比如效率一般的情况下没有哈希表高）。<br />    并且也弥补了上面数据结构的缺点。<br />为了模拟某些场景，我们使用树结构会更加方便。<br />    树结构是非线性的，可以表示一对多的关系。<br />    比如文件的目录结构。 |                                                              |

 

树的常用术语：



### 表示方式

 儿子-兄弟表示法

![image-20210125140606050](imgs/image-20210125140606050.png)



儿子-兄弟表示法旋转

![image-20210125141043549](imgs/image-20210125141043549.png)

- 规律：所有的树都可以使用**二叉树**模拟出来



### 二叉树

树中每个节点最多只能有两个子节点，即是二叉树。

二叉树的特性：

-  一个二叉树第i层的最大节点数：`2^(i-1)，i>=1`

- 深度为k的二叉树有最大节点总数：`2^k-1,k>=1`

- 对任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非叶节点个数，那么二者满足关系`n0=n2+1`

完美二叉树：

- 除了最下一层的叶节点外，每层节点都有2个子节点，构成满二叉树

完全二叉树：

- 除二叉树最后一层外，其他各层的节点数都达到最大个数
- 最后一层从左向右的叶节点连续存在，只缺右侧若干节点
- 完美二叉树是特殊的完全二叉树



### 二叉树的存储

二叉树可以用数组和链表存储。

二叉树最常见的存储方式是使用链表存储。

- 每个节点封装成一个Node，Node中包含存储的数据、左节点的引用、右节点的引用

![image-20210125143544776](imgs/image-20210125143544776.png)

### 二叉搜索树

#### 什么是二叉搜索树？

二叉搜索树（BST，Binary Search Tree），也称二叉排序树、二叉查找树。

二叉搜索树：

- 可以为空
- 如果不为空，满足以下性质：
  - 非空左子树的所有键值小于其根节点的键值
  - 非空右子树的所有键值大于其根节点的键值
  - 左右子数本身也是二叉搜索树

二叉搜索树的特点：

- 相对较小（相对父节点）的值总是保存在左节点上，相对较大的值总是保存在右节点上。
- 大大提高查找效率，二分查找的思想



#### 二叉搜索树的封装

```javascript
function BinarySerachTree() {
  this.root = null

  function Node(key) {
    this.key = key
    this.left = null
    this.right = null
  }
}
```



#### 二叉搜索树的常见操作

- `insert(key)`
- search(key)
- delete(key)
- tranverse--遍历
  - inOrderTraversal--中序遍历
  - preOrderTraversal--先序遍历
  - postOrderTraversal--后序遍历

- min()
- max()
- remove(key)

#### 插入方法

```javascript
BinarySerachTree.prototype.insert = function(key) {
  var newNode = new Node(key)
  if (this.root === null) {
    this.root = newNode
  } else {
    this.insertNode(this.root, newNode)
  }
}
```



#### 遍历方法

树的遍历：访问树的每个节点。

常见方式：

- 先序遍历
  - 访问根节点
  - 先序遍历其左子树
  - 先序遍历其右子树
- 中序遍历
  - 中序遍历其左子树
  - 访问根节点
  - 中序遍历其右子树
- 后序遍历
  - 后序遍历其左子树
  - 后序遍历其右子树
  - 访问根节点
- 层序遍历



先序遍历的代码实现

```javascript
BinarySerachTree.prototype.preOrderTraversal = function(handler) {
  this.preOrderTraversalNode(this.root, handler)
}

BinarySerachTree.prototype.preOrderTraversalNode = function(node, handler) {
  if (node !== null) {
    handler(node.key)
    this.preOrderTraversalNode(node.left, handler)
    this.preOrderTraversalNode(node.right, handler)
  }
}
```



中序遍历的代码实现

```javascript
BinarySerachTree.prototype.postOrderTraversal = function(handler) {
  this.postOrderTraversalNode(this.root, handler)
}

BinarySerachTree.prototype.postOrderTraversalNode = function(node, handler) {
  if (node !== null) {
    this.postOrderTraversalNode(node.left, handler)
    this.postOrderTraversalNode(node.right, handler)
    handler(node.key)
  }
}
```



后序遍历的代码实现

```javascript
BinarySerachTree.prototype.midOrderTraversal = function(handler) {
  this.midOrderTraversalNode(this.root, handler)
}

BinarySerachTree.prototype.midOrderTraversalNode = function(node, handler) {
  if (node !== null) {
    this.midOrderTraversalNode(node.left, handler)
    handler(node.key)
    this.midOrderTraversalNode(node.right, handler)
  }
}
```



#### 最大值和最小值

```javascript
BinarySerachTree.prototype.min = function() {
  var current = this.root
  while(current.left !== null) {
    current = current.left
  }
  return current.key
}

BinarySerachTree.prototype.max = function() {
  var current = this.root
  while(current.right !== null) {
    current = current.right
  }
  return current.key
}
```



#### 搜索特定的值

```javascript
BinarySerachTree.prototype.search = function(key) {
  var node = this.root
  while(node) {
    if (key < node.key) {
      node = node.left
    } else if (key > node.key) {
      node = node.right
    } else {
      return true
    }
  }
  return false
}
```





#### 删除方法

- 删除节点要从查找要删的节点开始，找到节点后，需考虑三种情况：
  - 该节点是叶节点
  - 该节点只有一个子节点
  - 该节点有两个子节点（情况复杂）
- 过程：
  - 先找到要删除的节点，如果没有找到，不需要删除
  - 找到要删除的节点
    - 删除叶子节点
    - 删除只有一个子节点的节点
    - 删除有两个子节点的节点

```javascript
BinarySerachTree.prototype.delete = function(key) {
  var node = this.root
  var parentNode
  var isLeft = true

  while(node.key !== key) {
    parentNode = node
    if (key < node.key) {
      node = node.left
      isLeft = true
    } else if (key > node.key) {
      node = node.right
      isLeft = false
    } 

    if (node === null) return false
  }

  if (node.left === null && node.right === null) { // 1. 该节点是叶节点
    if(isLeft) {
      parentNode.left = null
    } else {
      parentNode.right = null
    }
  } else if (node.left === null) { // 2. 该节点只有一个子节点
    if (node === this.root) {
      this.root = node.right
    } else if (isLeft) {
      parentNode.left = node.right
    } else {
      parentNode.right = node.right
    }
  } else if (node.right === null) { 
    if (node === this.root) {
      this.root = node.left
    } else if (isLeft) {
      parentNode.left = node.left
    } else {
      parentNode.right = node.left
    }
  } else { // 3. 该节点有两个子节点 
    var successor = this.getSuccessor(node)
    if (node === this.root) {
      this.root = successor
    }
    if (isLeft) {
      parentNode.left = successor
    } else {
      parentNode.right = successor
    }
    successor.left = node.left
  }
  return true
}
```

获取后继节点：

```javascript
// 获取后继节点
BinarySerachTree.prototype.getSuccessor = function(delNode) {
  var successorParent = delNode
  var successor = delNode
  var current = delNode.right
  while(current !== null) {
    successorParent = successor
    successor = current
    current = current.left
  }

  console.log(successor)
  console.log(successorParent)
  if (delNode !== successorParent) {

    successorParent.left = successor.right
    successor.right = delNode.right
  }

  console.log(successor)
  return successor
}
```

